# Performance/Scalability Report: Memory Observability

- Дата: 2026-02-19
- Scope: `doctor`, `setup`, `gain -p`, `discover`, `devenv`

## Итог

Текущая реализация функционально рабочая для локального dev-потока, но есть архитектурные узкие места в точности метрик и формате API-вывода (`discover --json`), которые ограничивают масштабирование observability.

## Основные риски

1. `discover --json` нестрогий контракт вывода
- Смешение JSON и текстового хвоста создаёт неустойчивый интерфейс для автоматизаций.

2. `gain -p` использует эвристику вместо событийной метрики
- `hook_fires` и savings выводятся не из полноценной телеметрии события инжекций, а из `cache_stats` + artifact-derived расчёта.

3. `setup` не эскалирует проблемы doctor
- Сценарий установки может завершаться "успешно" даже при фактических FAIL/WARN.

## Производительность

- `doctor`: O(1) по БД + чтение `settings.json`; дешёвый путь, подходит для частого вызова.
- `discover`: O(N) по JSONL-сессиям; при росте объёма логов нужен строгий limit/streaming-подход (частично уже есть через `limit` в выводе).
- `devenv`: нагрузка определяется внешними watcher-процессами; orchestration внутри команды лёгкий.

## Рекомендации

1. Стабилизировать output-контракты
- Для `discover --json` вернуть единый JSON-объект, включая memory-miss секцию.

2. Унифицировать модель метрик memory hook
- Привести PRD/ADR/реализацию к одной схеме таблиц и полей, после чего формировать строку `rtk memory (hook)` прямо в `By Command`.

3. Сделать `setup` fail-aware
- Пробрасывать статус doctor в итоговый exit code/сообщение setup.

## Прогноз на рост

- 3 пользователя: low risk.
- 100 пользователей: medium risk из-за контрактов вывода и точности метрик.
- 1000 пользователей: high risk, если не ввести контрактные тесты на CLI output и deterministic telemetry schema.
